import { useEffect, useRef, useState } from 'react'
import createVerovioModule from 'verovio/wasm'
import { VerovioToolkit } from 'verovio/esm'
import { transposeMusicXML } from '../utils/musicxml-transpose'

export interface Part {
  id: string
  name: string
  index: number
  voiceIndex?: number
}

export interface MusicMetadata {
  title?: string
  subtitle?: string
  composer?: string
  lyricist?: string
  copyright?: string
}

interface SheetViewerProps {
  musicXml: string | null
  selectedPart?: string
  transpose?: number
  onPartsLoaded?: (parts: Part[]) => void
}

export function SheetViewer({
  musicXml,
  selectedPart = '',
  transpose = 0,
  onPartsLoaded
}: SheetViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const verovioRef = useRef<VerovioToolkit | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [isInitialized, setIsInitialized] = useState(false)
  const [loadedParts, setLoadedParts] = useState<Part[]>([])

  // Initialize Verovio
  useEffect(() => {
    let mounted = true

    const initVerovio = async () => {
      try {
        console.log('Initializing Verovio...')
        const VerovioModule = await createVerovioModule()
        const vrvToolkit = new VerovioToolkit(VerovioModule)
        
        if (mounted) {
          verovioRef.current = vrvToolkit
          setIsInitialized(true)
          console.log('Verovio initialized')
        }
      } catch (err) {
        console.error('Verovio init error:', err)
        if (mounted) {
          setError('Failed to initialize Verovio')
        }
      }
    }

    initVerovio()

    return () => {
      mounted = false
    }
  }, [])

  // Load and render MusicXML
  useEffect(() => {
    if (!musicXml || !verovioRef.current || !isInitialized || !containerRef.current) return

    const loadAndRender = async () => {
      setIsLoading(true)
      setError(null)

      try {
        const vrv = verovioRef.current!
        
        console.log('Loading MusicXML with transpose:', transpose, 'selectedPart:', selectedPart)

        // Apply transposition if needed by preprocessing the MusicXML
        const processedXml = transpose !== 0
          ? transposeMusicXML(musicXml, transpose, selectedPart)
          : musicXml

        // Load the (possibly transposed) MusicXML
        const success = vrv.loadData(processedXml)
        if (!success) {
          throw new Error('Failed to load MusicXML')
        }

        // Set rendering options
        vrv.setOptions({
          scale: 40,
          adjustPageHeight: true,
          pageWidth: 2100,
          pageMarginLeft: 50,
          pageMarginRight: 50,
          pageMarginTop: 50,
          pageMarginBottom: 50,
        })

        // Render all pages to SVG
        const pageCount = vrv.getPageCount()
        console.log('Page count:', pageCount)

        if (containerRef.current) {
          containerRef.current.innerHTML = ''

          // Render each page and append to container
          for (let page = 1; page <= pageCount; page++) {
            let svg = vrv.renderToSVG(page)

            // Fix generic "Voice" labels in the SVG by adding voice numbers
            svg = fixVoiceLabelsInSVG(svg)

            // Hide auto-generated footer elements
            svg = hideAutoGeneratedFooter(svg)

            // Fix title and composer formatting
            svg = fixTitleAndComposerInSVG(svg)

            const pageDiv = document.createElement('div')
            pageDiv.className = 'sheet-page'
            pageDiv.style.marginBottom = 'var(--space-lg)'
            pageDiv.innerHTML = svg
            containerRef.current.appendChild(pageDiv)
          }
        }

        // Extract parts from the MEI data
        const meiData = vrv.getMEI()
        const parts = extractPartsFromMEI(meiData)

        console.log('Extracted parts:', parts)

        setLoadedParts(parts)

        if (onPartsLoaded) {
          onPartsLoaded(parts)
        }

        // Apply highlighting if part is selected
        if (containerRef.current) {
          applyHighlighting(containerRef.current, selectedPart, parts)
        }

      } catch (err) {
        console.error('Load error:', err)
        setError(err instanceof Error ? err.message : 'Failed to load sheet music')
      } finally {
        setIsLoading(false)
      }
    }

    loadAndRender()
  }, [musicXml, transpose, selectedPart, isInitialized, onPartsLoaded])

  // Apply highlighting when selectedPart changes (without re-rendering everything)
  useEffect(() => {
    if (!containerRef.current) {
      console.warn('containerRef.current is null, cannot apply highlighting')
      return
    }

    console.log('Selected part changed to:', selectedPart)
    console.log('Container has children:', containerRef.current.children.length)
    applyHighlighting(containerRef.current, selectedPart, loadedParts)
  }, [selectedPart, loadedParts])

  // Fix generic "Voice" labels in SVG to show voice numbers
  const fixVoiceLabelsInSVG = (svg: string): string => {
    // Parse the SVG to find and replace "Voice" text elements
    const parser = new DOMParser()
    const svgDoc = parser.parseFromString(svg, 'image/svg+xml')

    // Find all text elements that contain just "Voice"
    const textElements = svgDoc.querySelectorAll('text')
    let voiceCounter = 1

    textElements.forEach(textEl => {
      const textContent = textEl.textContent?.trim()
      if (textContent === 'Voice') {
        // Replace with "Voice N" where N is the voice number
        textEl.textContent = `Voice ${voiceCounter}`
        voiceCounter++
      }
    })

    // Serialize back to string
    const serializer = new XMLSerializer()
    return serializer.serializeToString(svgDoc)
  }

  // Hide auto-generated footer elements
  const hideAutoGeneratedFooter = (svg: string): string => {
    const parser = new DOMParser()
    const svgDoc = parser.parseFromString(svg, 'image/svg+xml')

    // Find all elements with class "pgFoot" and "autogenerated"
    const footerElements = svgDoc.querySelectorAll('.pgFoot.autogenerated')
    footerElements.forEach(el => {
      // Hide by setting display to none
      el.setAttribute('display', 'none')
    })

    // Serialize back to string
    const serializer = new XMLSerializer()
    return serializer.serializeToString(svgDoc)
  }

  // Fix title and composer formatting in SVG
  const fixTitleAndComposerInSVG = (svg: string): string => {
    const parser = new DOMParser()
    const svgDoc = parser.parseFromString(svg, 'image/svg+xml')

    // Find the pgHead group
    const pgHead = svgDoc.querySelector('.pgHead')
    if (!pgHead) return svg

    // Get the actual coordinate system from viewBox or SVG dimensions
    const svgElement = svgDoc.querySelector('svg')
    let centerX = 10500 // Default center for typical Verovio page (pageWidth 2100 * scale 40 / 8)

    if (svgElement) {
      const viewBox = svgElement.getAttribute('viewBox')
      if (viewBox) {
        // viewBox format: "minX minY width height"
        const parts = viewBox.split(/\s+/)
        if (parts.length === 4) {
          const width = parseFloat(parts[2])
          centerX = width / 2
        }
      }
    }

    // Find all text elements in the header
    const textElements = Array.from(pgHead.querySelectorAll('text'))
    if (textElements.length === 0) return svg

    // If only 1 element, it's the title. If 2+, last is composer, rest are title
    const titleElements = textElements.length === 1 ? textElements : textElements.slice(0, -1)
    const composerElement = textElements.length > 1 ? textElements[textElements.length - 1] : null

    // Style title elements (center, big, bold)
    let currentY = 400 // Start position for title
    titleElements.forEach((textEl) => {
      const tspan = textEl.querySelector('tspan.rend')
      if (tspan) {
        tspan.setAttribute('x', centerX.toString())
        tspan.setAttribute('y', currentY.toString())
        tspan.setAttribute('text-anchor', 'middle')

        // Find the innermost tspan with font-size and make it bold and larger
        const innerTspan = textEl.querySelector('tspan[font-size]')
        if (innerTspan) {
          innerTspan.setAttribute('font-weight', 'bold')
          innerTspan.setAttribute('font-size', '500px') // Bigger
        }
      }
      currentY += 450 // Spacing between title lines
    })

    // Style composer element (center, keep original size, italic)
    if (composerElement) {
      const composerTspan = composerElement.querySelector('tspan.rend')
      if (composerTspan) {
        composerTspan.setAttribute('x', centerX.toString())
        composerTspan.setAttribute('y', currentY.toString())
        composerTspan.setAttribute('text-anchor', 'middle')

        // Find the innermost tspan with font-size and make it italic (keep original size)
        const innerTspan = composerElement.querySelector('tspan[font-size]')
        if (innerTspan) {
          innerTspan.setAttribute('font-style', 'italic')
          // Keep original font-size (don't change it)
        }
      }
    }

    // Serialize back to string
    const serializer = new XMLSerializer()
    return serializer.serializeToString(svgDoc)
  }

  // Extract parts from MEI XML
  const extractPartsFromMEI = (meiData: string): Part[] => {
    const parser = new DOMParser()
    const meiDoc = parser.parseFromString(meiData, 'text/xml')

    const parts: Part[] = [
      { id: 'all', name: 'All voices', index: -1 }
    ]

    console.log('Extracting parts from MEI...')

    // Find all staffDef elements in MEI
    const staffDefs = meiDoc.querySelectorAll('staffDef')
    console.log('Found', staffDefs.length, 'staffDef elements')

    let globalVoiceNumber = 1

    staffDefs.forEach((staffDef, index) => {
      const staffNum = staffDef.getAttribute('n') || (index + 1).toString()
      let label = staffDef.getAttribute('label') || `Part ${staffNum}`

      console.log(`Staff ${staffNum}: label="${label}"`)

      // Fix generic "Voice" labels to use Part naming
      if (label.trim() === 'Voice') {
        label = `Part ${staffNum}`
      }

      // Look for all staff elements with matching n attribute, then find layers within
      const staffElements = meiDoc.querySelectorAll(`staff[n="${staffNum}"]`)
      console.log(`Found ${staffElements.length} staff elements for staff ${staffNum}`)

      if (staffElements.length > 0) {
        // Collect all unique layers across all instances of this staff
        const layersSet = new Set<string>()
        staffElements.forEach(staffEl => {
          const layers = staffEl.querySelectorAll('layer')
          layers.forEach(layer => {
            const layerN = layer.getAttribute('n') || '1'
            layersSet.add(layerN)
          })
        })

        const uniqueLayers = Array.from(layersSet).sort()
        console.log(`Staff ${staffNum} has ${uniqueLayers.length} unique layers:`, uniqueLayers)

        // Always add individual layer entries with global voice numbering
        uniqueLayers.forEach((layerN, voiceIdx) => {
          parts.push({
            id: `staff-${staffNum}-layer-${layerN}`,
            name: `${label} - Voice ${globalVoiceNumber}`,
            index: parseInt(staffNum) - 1,
            voiceIndex: voiceIdx
          })
          globalVoiceNumber++
        })
      }
    })

    console.log('Extracted parts:', parts)
    return parts
  }

  // Apply highlighting by manipulating SVG
  const applyHighlighting = (container: HTMLElement, partId: string, availableParts: Part[]) => {
    console.log('=== Highlighting Debug ===')
    console.log('Selected partId:', partId)
    console.log('Container element:', container)
    console.log('Container HTML length:', container.innerHTML.length)

    // Get all SVGs (one per page)
    const svgs = container.querySelectorAll('svg')
    console.log('Found SVG elements:', svgs.length)
    if (svgs.length === 0) {
      console.error('No SVG elements found in container!')
      return
    }

    // If no part selected or 'all' is selected, show everything at full opacity
    if (!partId || partId === '' || partId === 'all') {
      console.log('Showing all voices')
      svgs.forEach(svg => {
        // Reset all elements
        const allElements = svg.querySelectorAll('[opacity]')
        allElements.forEach(el => el.removeAttribute('opacity'))
      })
      return
    }

    // Extract staff and layer from partId (e.g., "staff-1-layer-2" -> staff=1, layer=2)
    const match = partId.match(/staff-(\d+)-layer-(\d+)/)
    if (!match) {
      console.warn('Invalid partId format:', partId)
      return
    }

    const targetStaffNum = parseInt(match[1])
    const targetLayerNum = parseInt(match[2])
    console.log(`Highlighting staff ${targetStaffNum}, layer ${targetLayerNum}`)

    // Determine how many distinct staffs we have from the parts data
    const distinctStaffs = new Set(
      availableParts
        .filter(p => p.id !== 'all')
        .map(p => p.index + 1) // Convert 0-based index to 1-based staff number
    )
    const staffsPerMeasure = distinctStaffs.size
    console.log(`Detected ${staffsPerMeasure} staffs per measure`)

    svgs.forEach((svg, pageIdx) => {
      console.log(`\n--- Processing page ${pageIdx + 1} ---`)

      // Use measures as grouping boundaries instead of simple modulo
      // This handles cases where the last system might have fewer staves
      const allMeasures = svg.querySelectorAll('g.measure')
      console.log(`Found ${allMeasures.length} measure elements`)

      let selectedCount = 0
      let dimmedCount = 0

      allMeasures.forEach((measure, measureIndex) => {
        // Within each measure, find all staff elements
        const staffsInMeasure = measure.querySelectorAll('g.staff')
        
        if (measureIndex < 3) {
          console.log(`  Measure ${measureIndex}: ${staffsInMeasure.length} staffs`)
        }

        staffsInMeasure.forEach((staff, staffIndexInMeasure) => {
          // staffIndexInMeasure is 0-based within this measure
          // Convert to 1-based musical staff number
          const musicalStaffNum = staffIndexInMeasure + 1
          const isTargetStaff = musicalStaffNum === targetStaffNum

          // Find all layers within this staff element
          const layers = staff.querySelectorAll('g.layer')

          if (measureIndex < 3 && staffIndexInMeasure < 4) {
            console.log(`    Staff ${staffIndexInMeasure} (musical staff ${musicalStaffNum}): ${layers.length} layers`)
          }

          layers.forEach((layer, layerIndex) => {
            const layerNum = layerIndex + 1 // Convert to 1-based
            const isTargetLayer = layerNum === targetLayerNum

            const isSelected = isTargetStaff && isTargetLayer

            if (measureIndex < 3 && staffIndexInMeasure < 4) {
              console.log(`      Layer ${layerNum}: ${isSelected ? 'SELECTED' : 'dimmed'}`)
            }

            // Apply opacity to the layer element
            if (isSelected) {
              layer.removeAttribute('opacity')
              selectedCount++
            } else {
              layer.setAttribute('opacity', '0.3')
              dimmedCount++
            }
          })
        })
      })

      console.log(`\nResults: ${selectedCount} selected, ${dimmedCount} dimmed`)
    })

    console.log('=========================')
  }

  if (error) {
    return (
      <div className="sheet-viewer-error">
        <p>Failed to load sheet music</p>
        <p style={{ fontSize: 'var(--font-size-sm)', marginTop: 'var(--space-sm)' }}>{error}</p>
      </div>
    )
  }

  if (!isInitialized) {
    return (
      <div className="sheet-viewer" style={{ padding: 'var(--space-md)', textAlign: 'center' }}>
        Initializing music renderer...
      </div>
    )
  }

  return (
    <div
      ref={containerRef}
      className="sheet-viewer"
      style={{
        width: '100%',
        height: '100%',
        overflow: 'auto',
        opacity: isLoading ? 0.5 : 1
      }}
    >
      {isLoading && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)'
        }}>
          Loading sheet music...
        </div>
      )}
    </div>
  )
}
